# 已连接设备扫描功能说明

## 📋 功能概述

在扫描阶段新增了**获取系统已连接设备**的功能，对应 CoreBluetooth 的 `retrieveConnectedPeripherals(withServices:)` 方法。

### 应用场景

1. **用户在系统设置中已连接了设备**
2. **其他 App 已连接了设备**
3. **需要在扫描列表中显示所有可用设备（包括已连接的）**
4. **快速重连之前连接过的设备**

---

## 🔧 实现细节

### 1. 修改的文件

#### **BlePublic.swift**
在 `BleFilter` 结构体中新增参数：

```swift
internal struct BleFilter {
    let serviceUUIDs: [CBUUID]?
    let allowDuplicates: Bool
    let includeConnectedDevices: Bool  // ✨ 新增
    
    init(serviceUUIDs: [CBUUID]? = nil, 
         allowDuplicates: Bool = false, 
         includeConnectedDevices: Bool = true) {  // ✨ 默认为 true
        self.serviceUUIDs = serviceUUIDs
        self.allowDuplicates = allowDuplicates
        self.includeConnectedDevices = includeConnectedDevices
    }
}
```

#### **BleCentral.swift**
新增 `retrieveConnectedDevices()` 方法：

```swift
private func retrieveConnectedDevices() {
    // 使用目标服务 UUID 获取已连接的设备
    let serviceUUIDs = scanFilter.serviceUUIDs ?? [targetServiceUUID]
    let connectedPeripherals = central.retrieveConnectedPeripherals(withServices: serviceUUIDs)
    
    for peripheral in connectedPeripherals {
        // 判断是否为目标设备
        if BleDeviceNameFilter.shared.isTargetDevice(peripheral: peripheral) {
            // 创建设备对象并回调
            let device = BleDevice(peripheral: peripheral, rssi: 0, macAddress: macAddress)
            discoveredDevices[peripheral.identifier] = device
            onFound?(device)
        }
    }
}
```

在 `beginScan()` 方法中调用：

```swift
private func beginScan() {
    seen.removeAll()
    
    // ✨ 如果需要包含已连接设备，先获取并返回它们
    if scanFilter.includeConnectedDevices {
        retrieveConnectedDevices()
    }
    
    central.scanForPeripherals(withServices: scanFilter.serviceUUIDs, options: opts)
}
```

#### **BleAPI.swift**
更新公开接口，添加可选参数：

```swift
/// 1️⃣ 扫描设备
/// - Parameter includeConnectedDevices: 是否包含系统已连接的设备（默认 true）
public func scan(includeConnectedDevices: Bool = true) {
    let filter = BleFilter(serviceUUIDs: nil, 
                          allowDuplicates: false, 
                          includeConnectedDevices: includeConnectedDevices)
    // ...
}
```

---

## 📖 使用方法

### 方法 1: 包含已连接设备（默认行为）✨ 推荐

```swift
let ble = BleAPI.shared

// 设置回调
ble.onDeviceFound = { deviceId, deviceName, rssi in
    print("发现设备: \(deviceName)")
    
    // 已连接设备的 RSSI 为 0
    if rssi == 0 {
        print("这是系统已连接的设备")
    }
}

// 开始扫描（默认包含已连接设备）
ble.scan()

// 或者显式指定
ble.scan(includeConnectedDevices: true)
```

### 方法 2: 不包含已连接设备

```swift
// 只扫描未连接的新设备
ble.scan(includeConnectedDevices: false)
```

### 方法 3: 分阶段扫描

```swift
// 第一阶段：获取已连接设备
ble.scan(includeConnectedDevices: true)

DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
    ble.stopScan()
    print("已连接设备扫描完成")
    
    // 第二阶段：扫描新设备
    ble.scan(includeConnectedDevices: false)
}
```

---

## ⚙️ 技术特点

### 1. 统一的回调接口

- 已连接设备和扫描设备使用**同一个 `onDeviceFound` 回调**
- 无需区分处理，简化外部代码逻辑

### 2. 自动设备过滤

- 使用 `BleDeviceNameFilter` 自动过滤目标设备
- 只返回符合条件的设备（例如设备名称匹配）

### 3. 自动缓存管理

- 已连接设备信息自动缓存到 `discoveredDevices`
- MAC 地址从本地存储中获取（如果之前保存过）
- 连接时可直接使用缓存的设备信息

### 4. 防重复机制

- 已连接设备会被标记到 `seen` 集合中
- 如果扫描到相同设备，不会重复回调（除非 `allowDuplicates = true`）

---

## 🔍 已连接设备的特点

### 优势

✅ **即时可用**：无需等待扫描，立即返回已连接设备  
✅ **连接稳定**：设备已处于连接状态，可直接通信  
✅ **节省时间**：跳过扫描和连接步骤，提升用户体验  

### 限制

⚠️ **RSSI 固定为 0**：无法获取实时信号强度（系统限制）  
⚠️ **MAC 地址可能缺失**：如果之前没有保存，MAC 地址为 `nil`  
⚠️ **可能被占用**：设备可能被其他 App 连接，需要断开才能重新连接  

### 如何区分已连接设备

```swift
ble.onDeviceFound = { deviceId, deviceName, rssi in
    if rssi == 0 {
        print("✅ 这是已连接的设备")
    } else {
        print("🔍 这是扫描发现的新设备，信号: \(rssi) dBm")
    }
}
```

---

## 🆚 与 OC 的对比

### Objective-C 原始方式

```objc
// 手动调用，获取数组
NSArray *connectedArr = [manager.manager retrieveConnectedPeripheralsWithServices:array1];

// 需要遍历处理
for (CBPeripheral *peripheral in connectedArr) {
    // 手动判断设备名称
    // 手动创建设备对象
    // 手动回调给上层
}
```

### Swift 新方式（本 SDK）✨

```swift
// 自动集成到 scan() 方法中
ble.scan(includeConnectedDevices: true)

// 统一回调，无需区分
ble.onDeviceFound = { deviceId, deviceName, rssi in
    // 已连接设备和扫描设备一起返回
}
```

### 优势对比

| 特性 | Objective-C | Swift SDK |
|------|-------------|-----------|
| 接口数量 | 需要额外调用 | 统一在 `scan()` 中 |
| 回调处理 | 需要分别处理 | 统一回调接口 |
| 设备过滤 | 手动判断 | 自动过滤 |
| 缓存管理 | 手动管理 | 自动缓存 |
| 代码复杂度 | 较高 | 极简 |

---

## 📝 使用建议

### ✅ 推荐做法

1. **默认包含已连接设备**：让用户看到所有可用设备
   ```swift
   ble.scan()  // 默认行为
   ```

2. **通过 RSSI 区分设备类型**：在 UI 上标注已连接设备
   ```swift
   if rssi == 0 {
       // 显示"已连接"标签
   }
   ```

3. **优先连接已连接设备**：提升用户体验
   ```swift
   // 先扫描已连接设备，优先展示给用户
   ```

### ⚠️ 注意事项

1. **重连问题**：如果设备已被其他 App 连接，需要先断开
   ```swift
   // 方案1: 先尝试连接，失败时提示用户断开其他连接
   // 方案2: 检测连接状态，如果已连接则提示用户
   ```

2. **MAC 地址缺失**：首次发现的已连接设备可能没有 MAC 地址
   ```swift
   if device.macAddress == nil {
       // 需要断开重连，从广播数据中获取 MAC 地址
   }
   ```

3. **性能考虑**：已连接设备立即返回，不影响扫描性能
   ```swift
   // retrieveConnectedPeripherals 是同步调用，速度很快
   ```

---

## 🧪 测试建议

### 测试场景 1：无已连接设备

1. 确保手机蓝牙设置中没有连接的设备
2. 调用 `ble.scan()`
3. 预期：只回调扫描到的新设备

### 测试场景 2：有已连接设备

1. 在手机蓝牙设置中连接目标设备
2. 调用 `ble.scan()`
3. 预期：
   - 立即回调已连接设备（RSSI = 0）
   - 之后陆续回调扫描到的新设备

### 测试场景 3：不包含已连接设备

1. 在手机蓝牙设置中连接目标设备
2. 调用 `ble.scan(includeConnectedDevices: false)`
3. 预期：不回调已连接设备，只回调扫描到的新设备

### 测试场景 4：重复扫描

1. 第一次扫描：`ble.scan()`（包含已连接设备）
2. 停止扫描：`ble.stopScan()`
3. 第二次扫描：`ble.scan()`
4. 预期：已连接设备再次回调（因为 `seen` 已清空）

---

## 📚 相关文档

- [已连接设备扫描示例.swift](./已连接设备扫描示例.swift) - 完整代码示例
- [SDK使用示例_带日志.swift](./SDK使用示例_带日志.swift) - 基础使用示例
- [多设备使用示例.swift](./多设备使用示例.swift) - 多设备管理示例

---

## 🎯 总结

这个功能将 CoreBluetooth 的 `retrieveConnectedPeripherals(withServices:)` 方法无缝集成到现有的扫描流程中，让外部调用者无需关心底层实现，只需通过一个简单的参数即可控制是否包含已连接设备。

**核心优势：**
- ✅ 接口简洁：只需一个参数
- ✅ 统一回调：已连接和扫描设备使用同一回调
- ✅ 自动管理：缓存、过滤、去重全自动
- ✅ 向后兼容：默认行为（包含已连接设备）符合用户预期

**适用场景：**
- 需要快速重连之前的设备
- 需要显示所有可用设备（包括已连接的）
- 需要优化首次连接体验

